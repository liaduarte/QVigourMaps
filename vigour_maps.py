# -*- coding: utf-8 -*-
"""
/***************************************************************************
 VigourMaps
                                 A QGIS plugin
 This plugin creates vigour maps.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-11-04
        git sha              : $Format:%H$
        copyright            : (C) 2020 by FCUP_UTAD
        email                : liaduarte@fc.up.pt
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QProgressBar, QTableWidgetItem
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import *
from qgis.core import *
from qgis.gui import *
from .reclassify_dialog import Ui_Reclassify

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .vigour_maps_dialog import VigourMapsDialog
from .vigour_maps_dialog import RectangleMapTool
import os.path
from processing.core.Processing import Processing


class VigourMaps:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'VigourMaps_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&VigourMaps')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        self.window = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('VigourMaps', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/vigour_maps/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Creates Vigour Maps'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&VigourMaps'),
                action)
            self.iface.removeToolBarIcon(action)

    def close_window_main(self):
        self.dlg.close()


    def run(self):

        """Run method that performs all the real work"""
        import time
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = VigourMapsDialog()
            self.dlg.pushButton_13.clicked.connect(self.fillNDVI)
            self.dlg.pushButton_21.clicked.connect(self.fillDSM)
            self.dlg.pushButton_18.clicked.connect(self.fillDTM)
            self.dlg.pushButton_17.clicked.connect(self.fillCSM)
            self.dlg.pushButton_19.clicked.connect(self.fillOutput)
            self.dlg.pushButton_20.clicked.connect(self.fillOutput_class)
            self.dlg.pushButton_16.clicked.connect(self.vectorStudy)
            self.dlg.pushButton.clicked.connect(self.reclassify)
            self.dlg.pushButton_2.clicked.connect(self.conclude)
            self.dlg.pushButton_3.clicked.connect(self.close_window_main)

            # Get all loaded layers in the interface
            layers = QgsProject.instance().mapLayers()

            # Create an empty list which we can populate
            list_names_layers = []
            # list of layer names using list comprehension
            l = [layer.name() for layer in QgsProject.instance().mapLayers().values()]
            # dictionary with key = layer name and value = layer object
            layers_list = {}
            for l in QgsProject.instance().mapLayers().values():
                layers_list[l.name()] = l
            for name, value in layers_list.items():
                list_names_layers.append(name)

            self.dlg.comboBox_3.addItems(list_names_layers)
            self.dlg.comboBox_9.addItems(list_names_layers)
            self.dlg.comboBox_6.addItems(list_names_layers)
            self.dlg.comboBox_8.addItems(list_names_layers)
            self.dlg.comboBox_7.addItems(list_names_layers)

            # show the dialog
            canvas = self.dlg.widget
            toolDraw = RectangleMapTool(canvas)
            canvas.setMapTool(toolDraw)

            # QLineEdit
            line_bbox = QLineEdit()
            line_bbox.hide()

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()


    def conclude(self):

        import time

        input_NDVI = self.dlg.comboBox_3.currentText()
        input_DSM = self.dlg.comboBox_9.currentText()
        input_DTM = self.dlg.comboBox_6.currentText()
        input_CSM = self.dlg.comboBox_8.currentText()
        study_zone = self.dlg.comboBox_7.currentText()

        canvas = self.dlg.widget
        toolDraw = RectangleMapTool(canvas)
        canvas.setMapTool(toolDraw)

        # QLineEdit
        line_bbox = QLineEdit()
        line_bbox.hide()

        progressMessageBar = self.iface.messageBar().createMessage("Processing...")
        progress = QProgressBar()
        progress.setMaximum(10)
        progress.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        progressMessageBar.layout().addWidget(progress)
        self.iface.messageBar().pushWidget(progressMessageBar, Qgis.Info)

        for i in range(10):
            time.sleep(1)
            progress.setValue(i + 1)


        self.output = self.dlg.lineEdit_22.text()
        #if csm is selected another output
        self.output_class_map_csm = self.dlg.lineEdit_23.text()
        #if there is study zone draw
        if len(toolDraw.points) !=0:
            poligono = QgsGeometry.fromPolygonXY([toolDraw.points])
            vl = QgsVectorLayer("Polygon", "temp", "memory")
            vl.setCrs(self.coord)
            pr = vl.dataProvider()
            f = QgsFeature()
            f.setGeometry(poligono)
            pr.addFeature(f)
            vl.updateExtents()
            QgsProject.instance().addMapLayer(vl)
            Processing.initialize()

            # input NDVI
            # clip the layers
            clip_ndvi1 = Processing.runAlgorithm("gdal:cliprasterbymasklayer", {
                'INPUT': str(input_NDVI),
                'MASK': vl,
                'SOURCE_CRS': None,
                'TARGET_CRS': None, 'NODATA': None,
                'ALPHA_BAND': False, 'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': False,
                'SET_RESOLUTION': False, 'X_RESOLUTION': None, 'Y_RESOLUTION': None,
                'MULTITHREADING': False, 'OPTIONS': '', 'DATA_TYPE': 0, 'EXTRA': '',
                'OUTPUT': QgsProcessingUtils.generateTempFilename('clip_ndvi1.tif')})
            self.out_ndvi = clip_ndvi1['OUTPUT']

            # mask for ndvi
            value_ndvi = self.dlg.doubleSpinBox_3.value()
            mask_ndvi = Processing.runAlgorithm("grass7:r.mapcalc.simple",
                                                {'a': self.out_ndvi,
                                                 'b': None,
                                                 'c': None, 'd': None, 'e': None, 'f': None,
                                                 'expression': '((A>' + str(value_ndvi) + ')*1)/((A>' + str(
                                                     value_ndvi) + ')*1+(A<=' + str(value_ndvi) + ')*0)',
                                                 'output': QgsProcessingUtils.generateTempFilename('mask_ndvi.tif'),
                                                 'GRASS_REGION_PARAMETER': None,
                                                 'GRASS_REGION_CELLSIZE_PARAMETER': 0, 'GRASS_RASTER_FORMAT_OPT': '',
                                                 'GRASS_RASTER_FORMAT_META': ''})
            self.mask_for_ndvi = mask_ndvi['output']

            if self.dlg.checkBox_3.isChecked() or self.dlg.checkBox_3.isChecked():

                # input DSM and DTM
                if self.dlg.checkBox_3.isChecked():

                    csm = Processing.runAlgorithm("grass7:r.mapcalc.simple", {'a': str(input_DSM),
                                                                               'b': str(input_DTM),
                                                                               'c': None, 'd': None, 'e': None, 'f': None,
                                                                               'expression': 'A-B',
                                                                               'output': QgsProcessingUtils.generateTempFilename('csm.tif'),
                                                                               'GRASS_REGION_PARAMETER': None,
                                                                               'GRASS_REGION_CELLSIZE_PARAMETER': 0,
                                                                               'GRASS_RASTER_FORMAT_OPT': '',
                                                                               'GRASS_RASTER_FORMAT_META': ''})
                    self.out_csm1 = csm['output']

                    # clip the layers
                    clip_csm = Processing.runAlgorithm("gdal:cliprasterbymasklayer", {
                        'INPUT': str(self.dlg.out_csm1),
                        'MASK': vl,
                        'SOURCE_CRS': None,
                        'TARGET_CRS': None, 'NODATA': None,
                        'ALPHA_BAND': False, 'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': False,
                        'SET_RESOLUTION': False, 'X_RESOLUTION': None, 'Y_RESOLUTION': None,
                        'MULTITHREADING': False, 'OPTIONS': '', 'DATA_TYPE': 0, 'EXTRA': '',
                        'OUTPUT': QgsProcessingUtils.generateTempFilename('clip_csm.tif')})
                    self.out_csm = clip_csm['OUTPUT']

                # input CSM
                if self.dlg.checkBox_2.isChecked():
                    # clip the layers
                    clip_csm = Processing.runAlgorithm("gdal:cliprasterbymasklayer", {
                        'INPUT': str(input_CSM),
                        'MASK': vl,
                        'SOURCE_CRS': None,
                        'TARGET_CRS': None, 'NODATA': None,
                        'ALPHA_BAND': False, 'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': False,
                        'SET_RESOLUTION': False, 'X_RESOLUTION': None, 'Y_RESOLUTION': None,
                        'MULTITHREADING': False, 'OPTIONS': '', 'DATA_TYPE': 0, 'EXTRA': '',
                        'OUTPUT': QgsProcessingUtils.generateTempFilename('clip_csm.tif')})
                    self.out_csm = clip_csm['OUTPUT']

                #mask for csm
                value_csm = self.dlg.doubleSpinBox_4.value()
                mask_csm = Processing.runAlgorithm("grass7:r.mapcalc.simple",
                                        {'a': str(self.out_csm),
                                         'b': None,
                                         'c': None, 'd': None, 'e': None, 'f': None, 'expression': '((A>'+ str(value_csm) +')*1)/((A>' + str(value_csm) +')*1+(A<=' + str(value_csm) + ')*0)',
                                         'output': QgsProcessingUtils.generateTempFilename('mask_csm.tif'), 'GRASS_REGION_PARAMETER': None,
                                         'GRASS_REGION_CELLSIZE_PARAMETER': 0, 'GRASS_RASTER_FORMAT_OPT': '',
                                         'GRASS_RASTER_FORMAT_META': ''})
                self.mask_for_csm = mask_csm['output']

                # mask for extra output classification map with csm and ndvi
                # class 2 - vegetation, class 1 = vegetation rasteira, class 0 =soil
                value_csm = self.dlg.doubleSpinBox_4.value()
                mask_csm = Processing.runAlgorithm("grass7:r.mapcalc.simple",
                                                   {'a': str(self.out_csm),
                                                    'b': str(self.out_ndvi),
                                                    'c': None, 'd': None, 'e': None, 'f': None,
                                                    'expression': '(A>' + str(value_csm) + 'AND B>' + str(value_ndvi)+')*2 ' + '(A<=' + str(value_csm) + 'AND B>' + str(value_ndvi) + ')*1',
                                                    'output': str(self.output_class_map_csm),
                                                    'GRASS_REGION_PARAMETER': None,
                                                    'GRASS_REGION_CELLSIZE_PARAMETER': 0, 'GRASS_RASTER_FORMAT_OPT': '',
                                                    'GRASS_RASTER_FORMAT_META': ''})

                #ndvi values for pixels with 1 in ndvi and csm
                ndvi_values_1 = Processing.runAlgorithm("grass7:r.mapcalc.simple",
                                        {'a': self.mask_for_ndvi,
                                         'b': self.mask_for_csm,
                                         'c': self.out_ndvi, 'd': None, 'e': None, 'f': None,
                                         'expression': '(A==1 & B==1)*C',
                                         'output': QgsProcessingUtils.generateTempFilename('ndvi_values_1.tif'), 'GRASS_REGION_PARAMETER': None,
                                         'GRASS_REGION_CELLSIZE_PARAMETER': 0, 'GRASS_RASTER_FORMAT_OPT': '',
                                         'GRASS_RASTER_FORMAT_META': ''})
                self.ndvi_values_for_1 = ndvi_values_1['output']

                resamp = Processing.runAlgorithm("saga:closegaps",
                                                 {'INPUT': self.ndvi_values_for_1,
                                                  'MASK': None,
                                                  'THRESHOLD': '0.1',
                                                  'RESULT': QgsProcessingUtils.generateTempFilename('resamp.sdat')
                                                  })

                self.out_resampling = resamp['RESULT']
                self.horizontal_filter = self.dlg.spinBox.value()
                self.vertical_filter = self.dlg.spinBox_2.value()
                resamp_filter = Processing.runAlgorithm("grass7:r.resamp.filter", {
                    'input': str(self.out_resampling),
                    'filter': [0], 'radius': '', 'x_radius': str(self.horizontal_filter),
                    'y_radius': str(self.vertical_filter), '-n': False,
                    'output': QgsProcessingUtils.generateTempFilename('resamp_filter.tif'),
                    'GRASS_REGION_PARAMETER': None,
                    'GRASS_REGION_CELLSIZE_PARAMETER': 0, 'GRASS_RASTER_FORMAT_OPT': '',
                    'GRASS_RASTER_FORMAT_META': ''})
                self.resamp_filter_to_result = resamp_filter['output']

                clip_resamp = Processing.runAlgorithm("gdal:cliprasterbymasklayer", {
                    'INPUT': str(self.resamp_filter_to_result),
                    'MASK': vl,
                    'SOURCE_CRS': None,
                    'TARGET_CRS': None, 'NODATA': None,
                    'ALPHA_BAND': False, 'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': False,
                    'SET_RESOLUTION': False, 'X_RESOLUTION': None, 'Y_RESOLUTION': None,
                    'MULTITHREADING': False, 'OPTIONS': '', 'DATA_TYPE': 0, 'EXTRA': '',
                    'OUTPUT': str(self.output)})

            else:
                # ndvi values for pixels with 1 in ndvi and csm
                ndvi_values_1 = Processing.runAlgorithm("grass7:r.mapcalc.simple",
                                                        {'a': self.mask_for_ndvi,
                                                         'b': self.out_ndvi,
                                                         'c': None, 'd': None, 'e': None, 'f': None,
                                                         'expression': '(A==1)*B',
                                                         'output': QgsProcessingUtils.generateTempFilename(
                                                             'ndvi_values_1.tif'), 'GRASS_REGION_PARAMETER': None,
                                                         'GRASS_REGION_CELLSIZE_PARAMETER': 0,
                                                         'GRASS_RASTER_FORMAT_OPT': '',
                                                         'GRASS_RASTER_FORMAT_META': ''})
                self.ndvi_values_for_1 = ndvi_values_1['output']

                resamp = Processing.runAlgorithm("saga:closegaps",
                                                 {'INPUT': self.ndvi_values_for_1,
                                                  'MASK': None,
                                                  'THRESHOLD':'0.1',
                                                  'RESULT': QgsProcessingUtils.generateTempFilename('resamp.sdat')
                                            })

                self.out_resampling = resamp['RESULT']
                self.horizontal_filter = self.dlg.spinBox.value()
                self.vertical_filter = self.dlg.spinBox_2.value()
                resamp_filter = Processing.runAlgorithm("grass7:r.resamp.filter", {
                    'input': str(self.out_resampling),
                    'filter': [0], 'radius': '', 'x_radius': str(self.horizontal_filter), 'y_radius': str(self.vertical_filter), '-n': False,
                    'output': QgsProcessingUtils.generateTempFilename('resamp_filter.tif'),
                    'GRASS_REGION_PARAMETER': None,
                    'GRASS_REGION_CELLSIZE_PARAMETER': 0, 'GRASS_RASTER_FORMAT_OPT': '',
                    'GRASS_RASTER_FORMAT_META': ''})
                self.resamp_filter_to_result = resamp_filter['output']

                clip_resamp = Processing.runAlgorithm("gdal:cliprasterbymasklayer", {
                    'INPUT': str(self.resamp_filter_to_result),
                    'MASK': vl,
                    'SOURCE_CRS': None,
                    'TARGET_CRS': None, 'NODATA': None,
                    'ALPHA_BAND': False, 'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': False,
                    'SET_RESOLUTION': False, 'X_RESOLUTION': None, 'Y_RESOLUTION': None,
                    'MULTITHREADING': False, 'OPTIONS': '', 'DATA_TYPE': 0, 'EXTRA': '',
                    'OUTPUT': str(self.output)})

        # if there is no study zone draw
        if len(toolDraw.points) ==0:

            # if study zone defined by shapefile
            if self.dlg.checkBox.isChecked():
                clip_ndvi1 = Processing.runAlgorithm("gdal:cliprasterbymasklayer", {
                    'INPUT': str(input_NDVI),
                    'MASK': study_zone,
                    'SOURCE_CRS': None,
                    'TARGET_CRS': None, 'NODATA': None,
                    'ALPHA_BAND': False, 'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': False,
                    'SET_RESOLUTION': False, 'X_RESOLUTION': None, 'Y_RESOLUTION': None,
                    'MULTITHREADING': False, 'OPTIONS': '', 'DATA_TYPE': 0, 'EXTRA': '',
                    'OUTPUT': QgsProcessingUtils.generateTempFilename('clip_ndvi1.tif')})
                self.out_ndvi = clip_ndvi1['OUTPUT']

                # mask for ndvi
                value_ndvi = self.dlg.doubleSpinBox_3.value()
                mask_ndvi = Processing.runAlgorithm("grass7:r.mapcalc.simple",
                                                    {'a': self.out_ndvi,
                                                     'b': None,
                                                     'c': None, 'd': None, 'e': None, 'f': None,
                                                     'expression': '((A>' + str(value_ndvi) + ')*1)/((A>' + str(
                                                         value_ndvi) + ')*1+(A<=' + str(value_ndvi) + ')*0)',
                                                     'output': QgsProcessingUtils.generateTempFilename(
                                                         'mask_ndvi.tif'), 'GRASS_REGION_PARAMETER': None,
                                                     'GRASS_REGION_CELLSIZE_PARAMETER': 0,
                                                     'GRASS_RASTER_FORMAT_OPT': '',
                                                     'GRASS_RASTER_FORMAT_META': ''})
                self.mask_for_ndvi = mask_ndvi['output']

                if self.dlg.checkBox_3.isChecked() or self.dlg.checkBox_2.isChecked():
                    if self.dlg.checkBox_3.isChecked():
                        csm = Processing.runAlgorithm("grass7:r.mapcalc.simple", {'a': str(input_DSM),
                                                                                  'b': str(input_DTM),
                                                                                  'c': None, 'd': None, 'e': None,
                                                                                  'f': None,
                                                                                  'expression': 'A-B',
                                                                                  'output': QgsProcessingUtils.generateTempFilename('csm.tif'),
                                                                                  'GRASS_REGION_PARAMETER': None,
                                                                                  'GRASS_REGION_CELLSIZE_PARAMETER': 0,
                                                                                  'GRASS_RASTER_FORMAT_OPT': '',
                                                                                  'GRASS_RASTER_FORMAT_META': ''})
                        self.out_csm1 = csm['output']

                        # clip the layers
                        clip_csm = Processing.runAlgorithm("gdal:cliprasterbymasklayer", {
                            'INPUT': str(self.dlg.out_csm1),
                            'MASK': study_zone,
                            'SOURCE_CRS': None,
                            'TARGET_CRS': None, 'NODATA': None,
                            'ALPHA_BAND': False, 'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': False,
                            'SET_RESOLUTION': False, 'X_RESOLUTION': None, 'Y_RESOLUTION': None,
                            'MULTITHREADING': False, 'OPTIONS': '', 'DATA_TYPE': 0, 'EXTRA': '',
                            'OUTPUT': QgsProcessingUtils.generateTempFilename('clip_csm.tif')})
                        self.out_csm = clip_csm['OUTPUT']

                    if self.dlg.checkBox_2.isChecked():
                        # clip the layers
                        clip_csm = Processing.runAlgorithm("gdal:cliprasterbymasklayer", {
                            'INPUT': str(input_CSM),
                            'MASK': study_zone,
                            'SOURCE_CRS': None,
                            'TARGET_CRS': None, 'NODATA': None,
                            'ALPHA_BAND': False, 'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': False,
                            'SET_RESOLUTION': False, 'X_RESOLUTION': None, 'Y_RESOLUTION': None,
                            'MULTITHREADING': False, 'OPTIONS': '', 'DATA_TYPE': 0, 'EXTRA': '',
                            'OUTPUT': QgsProcessingUtils.generateTempFilename('clip_csm.tif')})
                        self.out_csm = clip_csm['OUTPUT']

                        # mask for csm
                        value_csm = self.dlg.doubleSpinBox_4.value()
                        mask_csm = Processing.runAlgorithm("grass7:r.mapcalc.simple",
                                                           {'a': str(self.out_csm),
                                                            'b': None,
                                                            'c': None, 'd': None, 'e': None, 'f': None,
                                                            'expression': '((A>' + str(value_csm) + ')*1)/((A>' + str(
                                                                value_csm) + ')*1+(A<=' + str(value_csm) + ')*0)',
                                                            'output': QgsProcessingUtils.generateTempFilename(
                                                                'mask_csm.tif'), 'GRASS_REGION_PARAMETER': None,
                                                            'GRASS_REGION_CELLSIZE_PARAMETER': 0,
                                                            'GRASS_RASTER_FORMAT_OPT': '',
                                                            'GRASS_RASTER_FORMAT_META': ''})
                        self.mask_for_csm = mask_csm['output']

                        # mask for extra output classification map with csm and ndvi
                        # class 2 - vegetation, class 1 = vegetation rasteira, class 0 =soil
                        value_csm = self.dlg.doubleSpinBox_4.value()
                        mask_csm = Processing.runAlgorithm("grass7:r.mapcalc.simple",
                                                           {'a': str(self.out_csm),
                                                            'b': str(self.out_ndvi),
                                                            'c': None, 'd': None, 'e': None, 'f': None,
                                                            'expression': '(A>' + str(value_csm) + ' & B>' + str(
                                                                value_ndvi) + ')*2 + ' + '(A<=' + str(
                                                                value_csm) + ' & B>' + str(value_ndvi) + ')*1',
                                                            'output': str(self.output_class_map_csm),
                                                            'GRASS_REGION_PARAMETER': None,
                                                            'GRASS_REGION_CELLSIZE_PARAMETER': 0,
                                                            'GRASS_RASTER_FORMAT_OPT': '',
                                                            'GRASS_RASTER_FORMAT_META': ''})

                        # ndvi values for pixels with 1 in ndvi and csm
                        ndvi_values_1 = Processing.runAlgorithm("grass7:r.mapcalc.simple",
                                                                {'a': self.mask_for_ndvi,
                                                                 'b': self.mask_for_csm,
                                                                 'c': self.out_ndvi, 'd': None, 'e': None, 'f': None,
                                                                 'expression': '(A==1 & B==1)*C',
                                                                 'output': QgsProcessingUtils.generateTempFilename(
                                                                     'ndvi_values_1.tif'), 'GRASS_REGION_PARAMETER': None,
                                                                 'GRASS_REGION_CELLSIZE_PARAMETER': 0,
                                                                 'GRASS_RASTER_FORMAT_OPT': '',
                                                                 'GRASS_RASTER_FORMAT_META': ''})
                        self.ndvi_values_for_1 = ndvi_values_1['output']

                        resamp = Processing.runAlgorithm("saga:closegaps",
                                                         {'INPUT': self.ndvi_values_for_1,
                                                          'MASK': None,
                                                          'THRESHOLD':'0.1',
                                                          'RESULT': QgsProcessingUtils.generateTempFilename('resamp.sdat')
                                                          })

                        self.out_resampling = resamp['RESULT']
                        self.horizontal_filter = self.dlg.spinBox.value()
                        self.vertical_filter = self.dlg.spinBox_2.value()


                        gaps_clip = Processing.runAlgorithm("gdal:cliprasterbymasklayer", {
                            'INPUT': str(self.out_resampling),
                            'MASK': study_zone,
                            'SOURCE_CRS': None,
                            'TARGET_CRS': None, 'NODATA': None,
                            'ALPHA_BAND': False, 'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': False,
                            'SET_RESOLUTION': False, 'X_RESOLUTION': None, 'Y_RESOLUTION': None,
                            'MULTITHREADING': False, 'OPTIONS': '', 'DATA_TYPE': 0, 'EXTRA': '',
                            'OUTPUT': QgsProcessingUtils.generateTempFilename('gaps_clip.tif')})
                        self.out_gaps_clip = gaps_clip['OUTPUT']


                        resamp_filter = Processing.runAlgorithm("grass7:r.resamp.filter", {
                            'input': str(self.out_gaps_clip),
                            'filter': [0], 'radius': '', 'x_radius': str(self.horizontal_filter), 'y_radius': str(self.vertical_filter), '-n': False,
                            'output': str(self.output), 'GRASS_REGION_PARAMETER': None,
                            'GRASS_REGION_CELLSIZE_PARAMETER': 0, 'GRASS_RASTER_FORMAT_OPT': '',
                            'GRASS_RASTER_FORMAT_META': ''})

                #
                else:
                    # ndvi values for pixels with 1 in ndvi and csm
                    ndvi_values_1 = Processing.runAlgorithm("grass7:r.mapcalc.simple",
                                                            {'a': self.mask_for_ndvi,
                                                             'b': self.out_ndvi,
                                                             'c': None, 'd': None, 'e': None, 'f': None,
                                                             'expression': '(A==1)*B',
                                                             'output': QgsProcessingUtils.generateTempFilename(
                                                                 'ndvi_values_1.tif'), 'GRASS_REGION_PARAMETER': None,
                                                             'GRASS_REGION_CELLSIZE_PARAMETER': 0,
                                                             'GRASS_RASTER_FORMAT_OPT': '',
                                                             'GRASS_RASTER_FORMAT_META': ''})
                    self.ndvi_values_for_1 = ndvi_values_1['output']

                    resamp = Processing.runAlgorithm("saga:closegaps",
                                                     {'INPUT': self.ndvi_values_for_1,
                                                      'MASK': None,
                                                      'THRESHOLD':'0.1',
                                                      'RESULT': QgsProcessingUtils.generateTempFilename('resamp.sdat')
                                                      })

                    self.out_resampling = resamp['RESULT']
                    self.horizontal_filter = self.dlg.spinBox.value()
                    self.vertical_filter = self.dlg.spinBox_2.value()
                    resamp_filter = Processing.runAlgorithm("grass7:r.resamp.filter", {
                        'input': str(self.out_resampling),
                        'filter': [0], 'radius': '', 'x_radius': str(self.horizontal_filter), 'y_radius': str(self.vertical_filter), '-n': False,
                        'output': QgsProcessingUtils.generateTempFilename('resamp_filter.tif'),
                        'GRASS_REGION_PARAMETER': None,
                        'GRASS_REGION_CELLSIZE_PARAMETER': 0, 'GRASS_RASTER_FORMAT_OPT': '',
                        'GRASS_RASTER_FORMAT_META': ''})
                    self.resamp_filter_to_result = resamp_filter['output']

                    clip_resamp = Processing.runAlgorithm("gdal:cliprasterbymasklayer", {
                        'INPUT': str(self.resamp_filter_to_result),
                        'MASK': study_zone,
                        'SOURCE_CRS': None,
                        'TARGET_CRS': None, 'NODATA': None,
                        'ALPHA_BAND': False, 'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': False,
                        'SET_RESOLUTION': False, 'X_RESOLUTION': None, 'Y_RESOLUTION': None,
                        'MULTITHREADING': False, 'OPTIONS': '', 'DATA_TYPE': 0, 'EXTRA': '',
                        'OUTPUT': str(self.output)})

            else:
                # if it is all the area
                self.out_ndvi = input_NDVI

                # mask for ndvi
                t4 = time.time()
                value_ndvi = self.dlg.doubleSpinBox_3.value()
                mask_ndvi = Processing.runAlgorithm("grass7:r.mapcalc.simple",
                                                    {'a': self.out_ndvi,
                                                     'b': None,
                                                     'c': None, 'd': None, 'e': None, 'f': None,
                                                     'expression': '((A>' + str(value_ndvi) + ')*1)/((A>' + str(
                                                         value_ndvi) + ')*1+(A<=' + str(value_ndvi) + ')*0)',
                                                     'output': QgsProcessingUtils.generateTempFilename('mask_ndvi.tif'),
                                                     'GRASS_REGION_PARAMETER': None,
                                                     'GRASS_REGION_CELLSIZE_PARAMETER': 0,
                                                     'GRASS_RASTER_FORMAT_OPT': '',
                                                     'GRASS_RASTER_FORMAT_META': ''})
                self.mask_for_ndvi = mask_ndvi['output']
                t5 = time.time()

                if self.dlg.checkBox_3.isChecked() or self.dlg.checkBox_3.isChecked():

                    if self.dlg.checkBox_3.isChecked():
                        csm = Processing.runAlgorithm("grass7:r.mapcalc.simple", {'a': str(input_DSM),
                                                                                  'b': str(input_DTM),
                                                                                  'c': None, 'd': None, 'e': None,
                                                                                  'f': None,
                                                                                  'expression': 'A-B',
                                                                                  'output': QgsProcessingUtils.generateTempFilename(
                                                                                      'csm.tif'),
                                                                                  'GRASS_REGION_PARAMETER': None,
                                                                                  'GRASS_REGION_CELLSIZE_PARAMETER': 0,
                                                                                  'GRASS_RASTER_FORMAT_OPT': '',
                                                                                  'GRASS_RASTER_FORMAT_META': ''})
                        self.out_csm = csm['output']

                    if self.dlg.checkBox_2.isChecked():
                        self.out_csm = input_CSM


                    # mask for csm
                    t2 = time.time()
                    value_csm = self.dlg.doubleSpinBox_4.value()
                    mask_csm = Processing.runAlgorithm("grass7:r.mapcalc.simple",
                                            {'a': str(self.out_csm),
                                             'b': None,
                                             'c': None, 'd': None, 'e': None, 'f': None,
                                             'expression': '((A>'+ str(value_csm) +')*1)/((A>' + str(value_csm) +')*1+(A<=' + str(value_csm) + ')*0)',
                                             'output': QgsProcessingUtils.generateTempFilename('mask_csm.tif'), 'GRASS_REGION_PARAMETER': None,
                                             'GRASS_REGION_CELLSIZE_PARAMETER': 0, 'GRASS_RASTER_FORMAT_OPT': '',
                                             'GRASS_RASTER_FORMAT_META': ''})
                    self.mask_for_csm = mask_csm['output']
                    t3 = time.time()

                    # ndvi values for pixels with 1 in ndvi and csm
                    t6 = time.time()
                    ndvi_values_1 = Processing.runAlgorithm("grass7:r.mapcalc.simple",
                                            {'a': str(self.mask_for_ndvi),
                                             'b': str(self.mask_for_csm),
                                             'c': str(self.out_ndvi), 'd': None, 'e': None, 'f': None,
                                             'expression': '(A==1 & B==1)*C',
                                             'output': QgsProcessingUtils.generateTempFilename('ndvi_values_1.tif'), 'GRASS_REGION_PARAMETER': None,
                                             'GRASS_REGION_CELLSIZE_PARAMETER': 0, 'GRASS_RASTER_FORMAT_OPT': '',
                                             'GRASS_RASTER_FORMAT_META': ''})
                    self.ndvi_values_for_1 = ndvi_values_1['output']

                    t7 = time.time()

                    t8 = time.time()
                    resamp = Processing.runAlgorithm("saga:closegaps",
                                                     {
                                                         'INPUT': str(self.ndvi_values_for_1),
                                                         'MASK': None,
                                                         'THRESHOLD':'0.1',
                                                         'RESULT': QgsProcessingUtils.generateTempFilename('resamp.sdat'),
                                                         })

                    self.out_resampling = resamp['RESULT']
                    t9 = time.time()

                    t10 = time.time()
                    self.horizontal_filter = self.dlg.spinBox.value()
                    self.vertical_filter = self.dlg.spinBox_2.value()
                    resamp_filter = Processing.runAlgorithm("grass7:r.resamp.filter", {
                        'input': str(self.out_resampling),
                        'filter': [0], 'radius': '', 'x_radius': str(self.horizontal_filter), 'y_radius': str(self.vertical_filter), '-n': False,
                        'output': QgsProcessingUtils.generateTempFilename('resamp_filter.tif'),
                        'GRASS_REGION_PARAMETER': None,
                        'GRASS_REGION_CELLSIZE_PARAMETER': 0, 'GRASS_RASTER_FORMAT_OPT': '',
                        'GRASS_RASTER_FORMAT_META': ''})
                    self.out_resampling_filter = resamp_filter['output']
                    t11 = time.time()

                    # convert from .sdat to .tif
                    Processing.runAlgorithm("gdal:translate",
                                   {'INPUT': str(self.out_resampling_filter), 'TARGET_CRS': None, 'NODATA': None,
                                    'COPY_SUBDATASETS': False, 'OPTIONS': '', 'EXTRA': '', 'DATA_TYPE': 0,
                                    'OUTPUT': str(self.output)})

                else:
                    # ndvi values for pixels with 1 in ndvi and csm
                    t6 = time.time()
                    ndvi_values_1 = Processing.runAlgorithm("grass7:r.mapcalc.simple",
                                                            {'a': str(self.mask_for_ndvi),
                                                             'b': str(self.out_ndvi),
                                                             'c': None, 'd': None, 'e': None, 'f': None,
                                                             'expression': '(A==1)*B',
                                                             'output': QgsProcessingUtils.generateTempFilename(
                                                                 'ndvi_values_1.tif'), 'GRASS_REGION_PARAMETER': None,
                                                             'GRASS_REGION_CELLSIZE_PARAMETER': 0,
                                                             'GRASS_RASTER_FORMAT_OPT': '',
                                                             'GRASS_RASTER_FORMAT_META': ''})
                    self.ndvi_values_for_1 = ndvi_values_1['output']

                    t7 = time.time()

                    t8 = time.time()
                    resamp = Processing.runAlgorithm("saga:closegaps",
                                                     {
                                                         'INPUT': str(self.ndvi_values_for_1),
                                                         'MASK': None,
                                                         'THRESHOLD':'0.1',
                                                         'RESULT': QgsProcessingUtils.generateTempFilename(
                                                             'resamp.sdat'),
                                                         })

                    self.out_resampling = resamp['RESULT']
                    t9 = time.time()

                    t10 = time.time()
                    self.horizontal_filter = self.dlg.spinBox.value()
                    self.vertical_filter = self.dlg.spinBox_2.value()
                    resamp_filter = Processing.runAlgorithm("grass7:r.resamp.filter", {
                        'input': str(self.out_resampling),
                        'filter': [0], 'radius': '', 'x_radius': str(self.horizontal_filter), 'y_radius': str(self.vertical_filter), '-n': False,
                        'output': QgsProcessingUtils.generateTempFilename('resamp_filter.tif'),
                        'GRASS_REGION_PARAMETER': None,
                        'GRASS_REGION_CELLSIZE_PARAMETER': 0, 'GRASS_RASTER_FORMAT_OPT': '',
                        'GRASS_RASTER_FORMAT_META': ''})
                    self.out_resampling_filter = resamp_filter['LOPASS']
                    t11 = time.time()

                    # convert from .sdat to .tif
                    Processing.runAlgorithm("gdal:translate",
                                            {'INPUT': str(self.out_resampling_filter), 'TARGET_CRS': None,
                                             'NODATA': None,
                                             'COPY_SUBDATASETS': False, 'OPTIONS': '', 'EXTRA': '', 'DATA_TYPE': 0,
                                             'OUTPUT': str(self.output)})
        # add result into canvas
        vigour_map = QFileInfo(str(self.output))
        rlayer_vigour = QgsRasterLayer(self.output, vigour_map.fileName(), 'gdal')
        QgsProject.instance().addMapLayer(rlayer_vigour)
        self.dlg.widget.setExtent(rlayer_vigour.extent())
        # set the map canvas layer set
        self.dlg.widget.setLayers([rlayer_vigour])
        if self.output_class_map_csm!=None:
            # add result into canvas
            dist_map = QFileInfo(str(self.output_class_map_csm))
            rlayer_dist = QgsRasterLayer(self.output_class_map_csm, dist_map.fileName(), 'gdal')
            QgsProject.instance().addMapLayer(rlayer_dist)
            self.dlg.widget.setExtent(rlayer_dist.extent())
            # set the map canvas layer set
            self.dlg.widget.setLayers([rlayer_dist])
            QMessageBox.about(self.dlg,"Message", "Vigour map and Vegetation Distribution Map are created!")
        else:
            QMessageBox.about(self.dlg, "Message", "Vigour map is created!")
        self.iface.messageBar().clearWidgets()

    def fillOutput(self):
        filename, filter_string = QFileDialog.getSaveFileName(self.dlg, "Select output file ", "", '*.tif')
        self.dlg.lineEdit_22.setText(filename)

    def fillOutput_class(self):
        filename, filter_string = QFileDialog.getSaveFileName(self.dlg, "Select output file ", "", '*.tif')
        self.dlg.lineEdit_23.setText(filename)

    def fillNDVI(self):
        filename, filter_string = QFileDialog.getOpenFileName(self.dlg, "Select NDVI map ", "", '*.tif')
        fileCI = str(filename)

        fileInfo = QFileInfo(fileCI)
        path = fileInfo.filePath()
        basename = fileInfo.baseName()

        # add the raster
        vlayer = QgsRasterLayer(path, basename)
        self.dlg.comboBox_3.addItem(filename)
        crs_raster = vlayer.crs()

        self.coord = self.crs(crs_raster)

        # add layer to the registry
        QgsProject.instance().addMapLayer(vlayer)

        # set extent to the extent of our layer
        self.dlg.widget.setExtent(vlayer.extent())

        # set the map canvas layer set
        self.dlg.widget.setLayers([vlayer])

    def fillDSM(self):
        filename, filter_string = QFileDialog.getOpenFileName(self.dlg, "Select DSM map ", "", '*.tif')
        fileCI = str(filename)

        fileInfo = QFileInfo(fileCI)
        path = fileInfo.filePath()
        basename = fileInfo.baseName()

        # add the raster
        vlayer = QgsRasterLayer(path, basename)
        self.dlg.comboBox_9.addItem(filename)
        crs_raster = vlayer.crs()

        self.coord = self.crs(crs_raster)

        # add layer to the registry
        QgsProject.instance().addMapLayer(vlayer)

        # set extent to the extent of our layer
        self.dlg.widget.setExtent(vlayer.extent())

        # set the map canvas layer set
        self.dlg.widget.setLayers([vlayer])

    def fillDTM(self):
        filename, filter_string = QFileDialog.getOpenFileName(self.dlg, "Select DTM map ", "", '*.tif')
        fileCI = str(filename)

        fileInfo = QFileInfo(fileCI)
        path = fileInfo.filePath()
        basename = fileInfo.baseName()

        # add the raster
        vlayer = QgsRasterLayer(path, basename)
        self.dlg.comboBox_6.addItem(filename)
        crs_raster = vlayer.crs()

        self.coord = self.crs(crs_raster)

        # add layer to the registry
        QgsProject.instance().addMapLayer(vlayer)

        # set extent to the extent of our layer
        self.dlg.widget.setExtent(vlayer.extent())

        # set the map canvas layer set
        self.dlg.widget.setLayers([vlayer])

    def fillCSM(self):
        filename, filter_string = QFileDialog.getOpenFileName(self.dlg, "Select CSM map ", "", '*.tif')
        fileCI = str(filename)

        fileInfo = QFileInfo(fileCI)
        path = fileInfo.filePath()
        basename = fileInfo.baseName()

        # add the raster
        vlayer = QgsRasterLayer(path, basename)
        self.dlg.comboBox_8.addItem(filename)
        crs_raster = vlayer.crs()

        self.coord = self.crs(crs_raster)

        # add layer to the registry
        QgsProject.instance().addMapLayer(vlayer)

        # set extent to the extent of our layer
        self.dlg.widget.setExtent(vlayer.extent())

        # set the map canvas layer set
        self.dlg.widget.setLayers([vlayer])

    def vectorStudy(self):
        filename, filter_string = QFileDialog.getOpenFileName(self.dlg, "Select Study zone ", "", '*.shp')
        fileCI = str(filename)

        fileInfo = QFileInfo(fileCI)
        path = fileInfo.filePath()
        basename = fileInfo.baseName()

        vlayer = QgsVectorLayer(path, basename)
        self.dlg.comboBox_7.addItem(filename)


    def bbox(self):
        r = tool.rectangle()
        line_bbox.setText(str(r.xMinimum()))
        line_bbox.show()

    def foo(self,rect):
        print(rect)

    def crs(self, crs):
        return crs

    def output_reclassify(self):
        filename, filter_string = QFileDialog.getSaveFileName(self.window, "Select output file ", "", '*.tif')
        self.window.lineEdit.setText(filename)

    def output_prescription(self):
        filename, filter_string = QFileDialog.getSaveFileName(self.window, "Select output file ", "", '*.shp')
        self.window.lineEdit_2.setText(filename)

    def quantile(self):

        input_raster = self.dlg.lineEdit_22.text()
        import numpy as np
        from osgeo import gdal, gdal_array

        dataset = gdal.Open(input_raster)
        band = dataset.GetRasterBand(1)
        nodata = band.GetNoDataValue()
        array = dataset.ReadAsArray()

        #number of rows
        nrows = int(self.window.tableWidget.rowCount())

        new_array = array
        nan_array = array

        nan_array[array == nodata] = np.nan

        # routine to obtain quantiles
        lista_quantile = [0]
        j = 0
        percentile_list = []
        value = 100/(int(nrows)-1)
        while j < int(nrows) - 1:
            lista_quantile.append(round(int(lista_quantile[j]) + value, 3))
            j = j + 1

        for ii in lista_quantile:
            percentile = np.nanpercentile(nan_array, int(ii))
            percentile_list.append(round(percentile,3))

        # values repeated in first column
        percentile_ = []
        for iii in range(0,nrows-1):
            # intermedian values for the first columns that are equal to the second columns
            val = float(percentile_list[iii]) + 0.001
            percentile_.append(round(val,3))

        numberRows = len(percentile_list)
        numberColumns = int(self.window.tableWidget.columnCount())
        self.window.tableWidget.setRowCount(numberRows)
        self.window.tableWidget.setColumnCount(numberColumns)

        self.window.tableWidget.setItem(0, 0, QTableWidgetItem('0'))

        # values repeated in first column
        for r in range(0, nrows):
            if r==0:
                self.window.tableWidget.setItem(r, 0, QTableWidgetItem('0'))
            else:
                self.window.tableWidget.setItem(r, 0, QTableWidgetItem(str(percentile_[r-1])))

        # values repeated in first column
        for r in range(0, nrows):
            self.window.tableWidget.setItem(r, 1, QTableWidgetItem(str(percentile_list[r])))

    def reclassify(self):
        if self.window is None:
            self.window = Window()
        self.window.show()
        self.window.pushButton.clicked.connect(self.run_reclassify)
        self.window.pushButton_4.clicked.connect(self.actionAdd)
        self.window.pushButton_3.clicked.connect(self.actionRemove)
        self.window.pushButton_5.clicked.connect(self.output_reclassify)
        self.window.pushButton_6.clicked.connect(self.output_prescription)
        self.window.pushButton_2.clicked.connect(self.close_window)
        self.window.pushButton_7.clicked.connect(self.quantile)

        input_raster = self.dlg.lineEdit_22.text()
        import numpy as np
        from osgeo import gdal, gdal_array

        # open the dataset and retrieve raster data as an array
        dataset = gdal.Open(input_raster)
        if dataset==None:
            QMessageBox.about(self.window, 'Warning','Warning: You should have the vigour map created!')
            self.close_window()
        else:
            band = dataset.GetRasterBand(1)
            nodata = band.GetNoDataValue()
            array = dataset.ReadAsArray()

            new_array = array
            nan_array = array

            nan_array[array == nodata] = np.nan

            percentile_0 = round(np.nanpercentile(nan_array, 0),3)
            percentile_50 = round(np.nanpercentile(nan_array, 50),3)
            percentile_100 = round(np.nanpercentile(nan_array, 100),3)

            # intermedian values for the first columns that are equal to the second columns
            percentile_0_ = percentile_0 + 0.001
            percentile_50_ = percentile_50 + 0.001
            percentile_100_ = percentile_100 + 0.001

            perc_0 = QTableWidgetItem(str(percentile_0))
            perc_50 = QTableWidgetItem(str(percentile_50))
            perc_100 = QTableWidgetItem(str(percentile_100))

            #intermedian values
            perc_0_ = QTableWidgetItem(str(percentile_0_))
            perc_50_ = QTableWidgetItem(str(percentile_50_))
            perc_100_ = QTableWidgetItem(str(percentile_100_))

            list = [perc_0, perc_50, perc_100]
            numberRows = len(list)
            numberColumns = int(self.window.tableWidget.columnCount())
            self.window.tableWidget.setRowCount(numberRows)
            self.window.tableWidget.setColumnCount(numberColumns)

            self.window.tableWidget.setItem(0, 0, QTableWidgetItem('0'))
            self.window.tableWidget.setItem(0, 1, perc_0)
            self.window.tableWidget.setItem(1, 0, perc_0_)
            self.window.tableWidget.setItem(1, 1, perc_50)
            self.window.tableWidget.setItem(2, 0, perc_50_)
            self.window.tableWidget.setItem(2, 1, perc_100)
            self.window.tableWidget.setItem(3, 0, perc_100_)

    def close_window(self):
        self.window.close()

    def run_reclassify(self):

        import time
        progressMessageBar = self.iface.messageBar().createMessage("Processing...")
        progress = QProgressBar()
        progress.setMaximum(10)
        progress.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        progressMessageBar.layout().addWidget(progress)
        self.iface.messageBar().pushWidget(progressMessageBar, Qgis.Info)

        for i in range(10):
            time.sleep(1)
            progress.setValue(i + 1)

        output_reclassify = self.window.lineEdit.text()

        # if there is vigour classes
        it = self.window.tableWidget.item(0, 2)
        if it:
            if it.text():
                    # run table to vigour class
                    lista = []
                    numberRows = int(self.window.tableWidget.rowCount())
                    numberColumns = int(self.window.tableWidget.columnCount())
                    for i in range(0, numberRows):
                        for j in range(0, numberColumns-1):
                            self.line = self.window.tableWidget.item(i, j).text()
                            lista = lista + [(self.line)]
                            string = ","
                            intervalos = string.join(lista)
                    results = list(map(float, lista))

                    #reclassify
                    Processing.runAlgorithm("native:reclassifybytable",
                                   {'INPUT_RASTER': str(self.dlg.lineEdit_22.text()),
                                    'RASTER_BAND': 1, 'TABLE': results, 'NO_DATA': -9999,
                                    'RANGE_BOUNDARIES': 0, 'NODATA_FOR_MISSING': False, 'DATA_TYPE': 5,
                                    'OUTPUT': str(output_reclassify)})

                    # add result into canvas
                    file_info_norm = QFileInfo(str(output_reclassify))
                    rlayer_new_norm = QgsRasterLayer(output_reclassify, file_info_norm.fileName(), 'gdal')
                    QgsProject.instance().addMapLayer(rlayer_new_norm)
                    self.dlg.widget.setExtent(rlayer_new_norm.extent())
                    # set the map canvas layer set
                    self.dlg.widget.setLayers([rlayer_new_norm])

        # if there is prescription classes
        it = self.window.tableWidget.item(0, 3)
        if it:
            if it.text():
                output_prescription = self.window.lineEdit_2.text()

                # run table to prescription class
                lista = []
                numberRows = int(self.window.tableWidget.rowCount())
                for i in range(0, numberRows):
                    for j in [0,1,3]:
                        self.line = self.window.tableWidget.item(i,j).text()
                        lista = lista + [(self.line)]
                        string = ","
                        intervalos = string.join(lista)
                results = list(map(float, lista))

                # reclassify
                reclass_prescription = Processing.runAlgorithm("native:reclassifybytable",
                                        {'INPUT_RASTER': str(self.dlg.lineEdit_22.text()),
                                         'RASTER_BAND': 1, 'TABLE': results, 'NO_DATA': -9999,
                                         'RANGE_BOUNDARIES': 0, 'NODATA_FOR_MISSING': False, 'DATA_TYPE': 5,
                                         'OUTPUT': QgsProcessingUtils.generateTempFilename('reclass_prescription.tif')})
                self.reclass_prescription = reclass_prescription['OUTPUT']

                Processing.runAlgorithm("gdal:polygonize", {
                    'INPUT': str(self.reclass_prescription),
                    'BAND': 1, 'FIELD': 'DN', 'EIGHT_CONNECTEDNESS': False, 'EXTRA': '', 'OUTPUT': str(output_prescription)})

                # add result into canvas
                file_info_norm = QFileInfo(str(output_prescription))
                rlayer_new_norm = QgsVectorLayer(output_prescription, file_info_norm.fileName(), 'ogr')
                QgsProject.instance().addMapLayer(rlayer_new_norm)
                self.dlg.widget.setExtent(rlayer_new_norm.extent())
                # set the map canvas layer set
                self.dlg.widget.setLayers([rlayer_new_norm])

        self.iface.messageBar().clearWidgets()

    # BUTTON ADD AND REMOVE CLASSES
    def actionAdd(self):
        n = self.window.tableWidget.rowCount()
        self.window.tableWidget.insertRow(n)
        n = self.window.tableWidget.rowCount()
        return True

    def actionRemove(self):
        n = self.window.tableWidget.rowCount()
        for i in range(1,n):
            self.window.tableWidget.removeRow(n-1)
        n = self.window.tableWidget.rowCount()
        return True

class Window(QWidget, Ui_Reclassify):
    def __init__(self, parent=None):
        QWidget.__init__(self, parent)
        self.setupUi(self)